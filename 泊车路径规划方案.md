# 自动泊车轨迹规划方案设计（Hybrid A* + Reeds-Shepp）

## 1. 目标与约束

### 1.1 目标

在给定停车场场景下，车辆初始姿态与道路方向存在夹角，规划一条可执行、无碰撞的泊车轨迹，使车辆进入目标车位。

### 1.2 已知约束

- 车辆尺寸：车长 `L`、车宽 `W`
- 车位尺寸：`Wp > W`、`Lp > L`
- 道路宽度：`Wr > L`
- 车辆转向受限：`|delta| <= delta_max`
- 最小转弯半径：`R_min = L / tan(delta_max)`

### 1.3 输出定义

- 输出路径：`P = {s_0, s_1, ..., s_N}`，其中 `s_i = (x_i, y_i, theta_i, gear_i)`
- 同时可输出控制序列：`U = {(delta_i, d_i)}`

## 2. 总体方案

方案采用两层结构：

1. **Hybrid A\***：负责全局搜索可行走廊（考虑障碍、边界、车辆运动学）。
2. **RS 终端连接（RS-shot）**：在接近目标位姿时，用 Reeds-Shepp 解析曲线快速精确对接终点。

该结构的核心优点：

- Hybrid A* 解决“复杂初始姿态 + 障碍约束”的全局可行性；
- RS 解决“末端姿态精确收敛 + 前后切换”的泊车特性。

## 3. 车位目标位姿获取

## 3.1 感知已提供目标位姿

如果感知模块直接输出 `s_goal = (xg, yg, thetag)`，规划器直接使用。

## 3.2 感知未提供位姿，仅提供车位四角点

设角点集合为 `P={p_i}_{i=1..4}`，每个角点均为二维向量 `p_i=[x_i,y_i]^T`。

### 步骤 A：角点排序（消除输入顺序不确定）

先计算角点几何中心：

```text
c = (1/4) * sum_{i=1..4} p_i = [c_x, c_y]^T
```

其中 `c` 是二维列向量，表示车位中心点坐标。
对每个角点构造相对中心向量 `d_i = p_i - c`，并计算极角 `a_i = atan2(d_i.y, d_i.x)`。
将 `a_i` 按降序排序（或升序后反转），得到顺时针序列 `q1,q2,q3,q4`。

### 步骤 B：长短边识别与开口侧判定

构造相邻边向量与边长：

```text
e1 = q2-q1, e2 = q3-q2, e3 = q4-q3, e4 = q1-q4
l_k = ||e_k||_2
```

若 `l1+l3 >= l2+l4`，则 `q1q2`、`q3q4` 为长边，`q2q3`、`q4q1` 为短边；反之交换。
取两条短边中点（短边分别为 `u_1u_2`、`u_3u_4`）：

```text
m_s1 = (u_1 + u_2)/2
m_s2 = (u_3 + u_4)/2
```

离车辆更近的一侧可判定为车位开口：

```text
其中 p_start = [x0, y0]^T 为车辆初始位置。
if ||m_s1 - p_start||_2 <= ||m_s2 - p_start||_2:
    m_open = m_s1, m_bottom = m_s2
else:
    m_open = m_s2, m_bottom = m_s1
```

车位纵向（开口指向库底）单位向量定义为：

```text
e_slot = (m_bottom - m_open) / ||m_bottom - m_open||_2
```

宽度方向取与 `e_slot` 正交的单位向量：

```text
e_w = [-e_slot.y, e_slot.x]^T
```

### 步骤 C：目标位姿计算

如果是车尾泊入，则最终静止时车头朝开口侧。
因此车辆航向应与 `-e_slot` 一致：

```text
theta_g = atan2((-e_slot).y, (-e_slot).x)
```

目标点可以从“库底中点回退”得到：

```text
p_goal = m_bottom - d_stop * e_slot + beta * e_w
```

其中：

- `d_stop`：距库底的停车安全距离，可以为 `0.1L ~ 0.2L`；
- `beta`：横向偏置，默认 `0`（居中泊入），需要贴线时可再设置小偏置。

最终目标位姿：

```text
s_goal = (p_goal.x, p_goal.y, theta_g)
```

## 4. Hybrid A* 原理与流程

## 4.1 状态、索引与搜索空间

- 连续状态：`s=(x,y,theta,gear)`
- 离散索引：`idx=(ix,iy,itheta)`，用于判重和 close set 管理
- 说明：状态连续保证可执行性，索引离散保证计算可控性。

## 4.2 节点扩展机制

普通 A* 扩展网格邻居；Hybrid A* 扩展“控制原语”：

- `gear in {+1,-1}`
- `delta in {-delta_max, 0, +delta_max}`（可扩展为更多离散角）
- 固定步长 `ds`

每个控制原语通过车辆运动学积分得到后继状态：

```text
x' = x + d*cos(theta)
y' = y + d*sin(theta)
theta' = theta + d/L*tan(delta)
```

## 4.3 可行性筛选

每个后继状态需通过三类检查：

1. 地图边界检查：是否在可行驶区域；
2. 碰撞检查：`s -> s'` 轨迹段采样，检查车辆包络是否与障碍相交；
3. 规则检查：换挡抖动抑制、过大转角变化惩罚等。

其中第 2 项可按“粗筛 + 精筛”实现。

### 4.3.1 轨迹段离散采样

对扩展段 `s -> s'` 以弧长步长 `Delta s_col` 采样：

```text
N = ceil(|d| / Delta s_col)
s_j = PROPAGATE(s, gear, delta, j*|d|/N),  j=0...N
```

只要任一采样状态 `s_j` 发生碰撞，则该扩展段判为不可行。

### 4.3.2 车辆包络矩形计算

在采样状态 `s_j=(x_j,y_j,theta_j)` 下，车辆中心为 `(x_j,y_j)`，半长 `a=L/2`，半宽 `b=W/2`。
车体局部坐标四顶点：

```text
v1_local=(+a,+b), v2_local=(+a,-b), v3_local=(-a,-b), v4_local=(-a,+b)
```

旋转矩阵：

```text
R(theta_j) = [[cos(theta_j), -sin(theta_j)],
              [sin(theta_j),  cos(theta_j)]]
```

世界坐标顶点：

```text
v_k = [x_j,y_j]^T + R(theta_j) * v_k_local
```

### 4.3.3 方法 A：膨胀栅格快速碰撞筛查（粗筛）

将占据栅格按车辆外接圆半径膨胀：

```text
r_inf = 0.5 * sqrt(L^2 + W^2)
```

若车体中心或包络顶点落入膨胀后障碍栅格，则记为“疑似碰撞”。
该方法速度快，仅用于 first-pass 过滤，不作为最终碰撞结论。

### 4.3.4 方法 B：SAT 矩形相交检测（精筛）

对车辆矩形 `A` 和障碍矩形/线段包围盒 `B`，取分离轴集合：

```text
U = {A 的两条边法向, B 的两条边法向}
```

对任一轴 `u in U`，投影区间为：

```text
I_A(u) = [min_i dot(a_i, u), max_i dot(a_i, u)]
I_B(u) = [min_j dot(b_j, u), max_j dot(b_j, u)]
```

若存在某轴满足：

```text
max I_A(u) < min I_B(u)  or  max I_B(u) < min I_A(u)
```

则两者可分离，不碰撞；若所有轴区间均重叠，则判定碰撞。

因此可按如下流程判定碰撞：

- 先用方法 A 快速判定“明显安全/疑似碰撞”；
- 对“疑似碰撞”样本再执行 SAT 精筛；
- 仅当 SAT 判定相交时，才最终记为碰撞；

## 4.4 代价函数设计

```text
g += |d|
   + w_rev * I(gear=-1)
   + w_switch * I(gear_k != gear_{k-1})
   + w_steer * |delta|
   + w_dsteer * |delta_k - delta_{k-1}|
f = g + h
```

启发函数 `h` ：

- `h1`: 欧氏距离；
- `h2`: RS 无障碍最短长度；
- 取 `h = max(h1, h2)`，减少无效扩展。

## 4.5 RS-shot 触发机制

当节点靠近目标区域时（如 `dist < 2~4m`），不再盲目网格扩展，而尝试一次 RS 解析连接：

- 若连接成功且无碰撞，直接结束；
- 若失败，继续 Hybrid A* 扩展。

## 5. Reeds-Shepp（RS）

### 5.1 问题定义与建模结论

RS 模块用于求解以下边值问题：给定起终位姿
`q0=(x0,y0,theta0)`、`q1=(x1,y1,theta1)`，在曲率约束 `|kappa|<=1/R_min` 下，求允许前进与倒车的最短可行曲线。

路径段仅由三类原语组成：

- `L`：左转定曲率圆弧（`kappa=+1/R_min`）
- `R`：右转定曲率圆弧（`kappa=-1/R_min`）
- `S`：直线段（`kappa=0`）

每段长度可带符号，正值表示前进，负值表示倒车，因此可自然表达换挡机动。

### 5.2 结构数量与候选集合

工程实现可采用“基础结构族 + 对称扩展”的标准做法：

- 基础结构族按段型可归纳为 `CSC`、`CCC` 及其扩展族（如含 4~5 段的组合）；
- 通过左右镜像（`L <-> R`）、时间反演（前进/倒车互换）及起终点互换，可由少量基础族扩展出完整候选；
- 按常用实现采用 **48 个 RS 候选词** 全枚举，并逐一求参与筛选；
- 代表性候选包括：`LSL`、`RSR`、`LSR`、`RSL`、`LRL`、`RLR`（其余由对称变换得到）。

### 5.3 归一化求解流程

设终点在起点坐标系下的归一化状态为 `(x,y,phi)`，其计算为：

```text
dx = x1 - x0, dy = y1 - y0
x  = ( cos(theta0)*dx + sin(theta0)*dy ) / R_min
y  = (-sin(theta0)*dx + cos(theta0)*dy ) / R_min
phi = WRAP(theta1 - theta0)
```

其中 `WRAP(.)` 表示角度归一化到 `(-pi, pi]` 或 `[0,2pi)`。

之后对 48 个模板逐个执行：

1. 按模板写出参数方程，解段参数 `p=[t,u,v,...]`；
2. 做可行性约束检查（如 `u>=0`、三角函数定义域合法）；
3. 计算归一化总长度 `L_n = sum_i |p_i|`；
4. 还原物理长度 `L = R_min * L_n`；
5. 对曲线离散采样做碰撞检测，保留最短无碰撞候选。

注：`p=[t,u,v,...]` 的物理含义

- `p` 是该模板各路径段的参数向量，顺序与模板段顺序一致；
- 对 `L/R` 段，参数表示圆弧转角（归一化半径为 1 时，数值也等于该段弧长）；
- 对 `S` 段，参数表示直线段长度；
- 例如 `LSL` 中 `p=[t,u,v]`，分别对应“左弧-直线-左弧”三段参数。

### 5.4 参数求解公式

记 `mod2pi(.)` 为角度映射到 `[0,2pi)`。以下给出常用模板的解析式（归一化半径=1）：

#### 5.4.1 `LSL`（`CSC`）

```text
xi  = x - sin(phi)
eta = y - 1 + cos(phi)
u   = sqrt(xi^2 + eta^2)
t   = mod2pi(atan2(eta, xi))
v   = mod2pi(phi - t)
```

可行条件：`u >= 0`（天然满足），总长度 `L_n = |t| + |u| + |v|`。

#### 5.4.2 `RSR`（`CSC`）

```text
xi  = x + sin(phi)
eta = y - 1 - cos(phi)
u   = sqrt(xi^2 + eta^2)
t   = mod2pi(atan2(-eta, xi))
v   = mod2pi(-phi - t)
```

总长度同样为 `L_n = |t| + |u| + |v|`。

#### 5.4.3 `LRL`（`CCC`）

先定义：

```text
xi  = x - sin(phi)
eta = y - 1 + cos(phi)
D   = sqrt(xi^2 + eta^2)
A   = acos(D/4)     (需满足 D <= 4)
```

则可取一组参数解：

```text
t = mod2pi(atan2(eta, xi) + A + pi/2)
u = mod2pi(pi - 2A)
v = mod2pi(phi - t + u)
```

可行条件核心是 `D<=4`（否则中间反向圆弧无实解）。

说明：其余模板（如 `LSR`、`RSL`、`RLR` 及 4~5 段族）按相同思路，通过坐标替换与对称变换可得到对应解析式。

## 6. 整体算法流程与核心伪代码

### 6.1 流程总结

1. 输入地图、车辆参数、初始位姿；
2. 由感知位姿或四角点反推得到 `s_goal`；
3. 初始化 Hybrid A* 开闭集并开始搜索；
4. 节点接近目标时触发 `RS-shot`；
5. RS 连接成功则直接拼接输出；
6. RS 失败则继续扩展，直到成功或返回失败。

### 6.2 伪代码

```pseudo
function GET_GOAL_POSE(slot_or_pose, p_start):
    if slot_or_pose is direct_pose:
        return slot_or_pose

    # A) 角点顺时针排序
    Q <- SORT_CORNERS_CLOCKWISE(slot_or_pose)         # q1,q2,q3,q4

    # B-C) 长短边识别 + 开口侧判定
    (_, short_edges) <- SPLIT_LONG_SHORT_EDGES(Q)
    (u_1, u_2) <- short_edges[0]
    (u_3, u_4) <- short_edges[1]
    m_s1 <- 0.5 * (u_1 + u_2)
    m_s2 <- 0.5 * (u_3 + u_4)

    if NORM(m_s1 - p_start) <= NORM(m_s2 - p_start):
        m_open <- m_s1; m_bottom <- m_s2
    else:
        m_open <- m_s2; m_bottom <- m_s1
    e_slot <- UNIT(m_bottom - m_open)
    e_w <- [-e_slot.y, e_slot.x]^T

    # D) 车尾泊入目标位姿：车头朝开口侧
    theta_g <- atan2((-e_slot).y, (-e_slot).x)
    p_goal <- m_bottom - d_stop * e_slot + beta * e_w
    return (p_goal.x, p_goal.y, theta_g)
```

```pseudo
function PLAN_PARKING(map, s_start, slot_or_pose):
    # 1) 统一目标入口：感知位姿或四角点
    s_goal <- GET_GOAL_POSE(slot_or_pose, p_start=s_start.xy)
    open <- priority_queue()
    close <- hash_set()
    push(open, Node(s_start, g=0, h=H(s_start, s_goal)))

    while open not empty:
        # 2) 始终展开 f 最小节点
        n <- pop_min_f(open)
        if INDEX(n) in close: continue
        add INDEX(n) to close

        # 3) 接近目标后触发 RS-shot
        if NEAR_GOAL(n.state, s_goal):
            rs <- RS_CONNECT_BEST(n.state, s_goal, map, R_min)
            if rs is valid:
                return BACKTRACK(n) + rs

        # 4) Hybrid A* 控制原语扩展
        for (gear, delta) in MOTION_PRIMITIVES:
            s2 <- PROPAGATE(n.state, gear, delta, ds)
            if not SEGMENT_FEASIBLE(n.state, s2, map): continue
            # 代价包含倒车/换挡/转角变化项，需使用父节点信息
            g2 <- n.g + EDGE_COST(n, s2, gear, delta)
            h2 <- H(s2, s_goal)
            push_or_update(open, Node(s2, g2, h2, parent=n))

    return FAIL
```

```pseudo
function RS_CONNECT_BEST(s_from, s_to, map, R_min):
    T <- NORMALIZE_TO_RS_FRAME(s_from, s_to, R_min)   # (x, y, phi)
    best <- NONE
    for word in RS_TEMPLATE_SET_48:
        # 每个模板解析求参，失败即跳过
        p <- SOLVE_RS_WORD(word, T)                   # 解 t,u,v,...
        if not p.valid: continue
        path <- BUILD_RS_PATH(word, p, R_min)
        # 有碰撞则不可作为终端连接
        if not PATH_COLLISION_FREE(path, map): continue
        # 保留最短可行候选
        if best is NONE or LENGTH(path) < LENGTH(best):
            best <- path
    return best
```

```pseudo
function SEGMENT_FEASIBLE(s_from, s_to, map):
    # 弧长采样该段，任一点越界或碰撞即判失败
    for sj in ARC_LENGTH_SAMPLES(s_from, s_to, Delta_s_col):
        if not IN_MAP(sj, map): return false
        # 内部实现：膨胀栅格粗筛(疑似) + SAT 精筛(最终)
        if COLLISION_AT_STATE(sj, map): return false
    return true
```

```pseudo
function COLLISION_AT_STATE(sj, map):
    V_car <- VEHICLE_BOX_VERTICES(sj)
    if not HITS_INFLATED_GRID([sj.x, sj.y], V_car, map):
        return false                    # 粗筛判定明显安全

    Obs <- NEARBY_OBSTACLE_BOXES(sj, map)
    for B in Obs:
        if SAT_INTERSECT(V_car, B.vertices):
            return true                 # 精筛确认碰撞
    return false                        # 粗筛命中但精筛未相交
```

注：`H` 推荐取 `max(欧氏距离, RS无障碍长度)`；`MOTION_PRIMITIVES={(gear,delta)}`，其中 `gear in {+1,-1}`，`delta` 为离散转角集合；`d_stop` 推荐 `0.1L~0.2L`，`beta` 默认 `0`。
